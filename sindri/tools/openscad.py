"""OpenSCAD 3D modeling tools for Sindri.

Provides tools for generating parametric 3D models using OpenSCAD,
rendering previews, exporting to STL, and optimizing for 3D printing.
"""

import re
import subprocess
import tempfile
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Optional
import structlog

from sindri.tools.base import Tool, ToolResult

log = structlog.get_logger()


class ShapeType(str, Enum):
    """Basic OpenSCAD primitive shapes."""

    CUBE = "cube"
    SPHERE = "sphere"
    CYLINDER = "cylinder"
    CONE = "cone"
    POLYHEDRON = "polyhedron"


class BooleanOp(str, Enum):
    """Boolean operations for combining shapes."""

    UNION = "union"
    DIFFERENCE = "difference"
    INTERSECTION = "intersection"


class RenderFormat(str, Enum):
    """Output formats for rendering."""

    PNG = "png"
    STL = "stl"
    OFF = "off"
    AMF = "amf"
    CSG = "csg"


@dataclass
class SCADParameter:
    """A parameter in an OpenSCAD model."""

    name: str
    value: float | int | str
    description: str = ""
    min_val: Optional[float] = None
    max_val: Optional[float] = None


@dataclass
class PrintabilityIssue:
    """An issue found during printability analysis."""

    severity: str  # warning, error
    issue_type: str
    description: str
    suggestion: str
    line_number: Optional[int] = None


class GenerateSCADTool(Tool):
    """Generate OpenSCAD code from text descriptions.

    Creates parametric 3D models for 3D printing using code-based CAD.
    """

    name = "generate_scad"
    description = """Generate OpenSCAD code from a text description.

Creates parametric 3D models using OpenSCAD's code-based CAD approach.

Features:
- Generate complete .scad files from descriptions
- Support for primitive shapes (cube, sphere, cylinder)
- Boolean operations (union, difference, intersection)
- Parametric design with customizable variables
- Modules for reusable components

Examples:
- generate_scad(description="A box with a lid", width=50, height=30, depth=40)
- generate_scad(description="Phone stand with 60 degree angle", angle=60)
- generate_scad(description="Gear with 24 teeth", teeth=24, module=1.5)
- generate_scad(description="Parametric enclosure for Raspberry Pi")"""

    parameters = {
        "type": "object",
        "properties": {
            "description": {
                "type": "string",
                "description": "Text description of the 3D model to generate",
            },
            "parametric": {
                "type": "boolean",
                "description": "Generate parametric model with variables (default: true)",
            },
            "include_comments": {
                "type": "boolean",
                "description": "Add explanatory comments to code (default: true)",
            },
            "units": {
                "type": "string",
                "description": "Units for measurements (mm, cm, inch)",
                "enum": ["mm", "cm", "inch"],
            },
            "width": {
                "type": "number",
                "description": "Width/X dimension if applicable",
            },
            "height": {
                "type": "number",
                "description": "Height/Z dimension if applicable",
            },
            "depth": {
                "type": "number",
                "description": "Depth/Y dimension if applicable",
            },
            "wall_thickness": {
                "type": "number",
                "description": "Wall thickness for hollow objects (default: 2mm)",
            },
            "custom_params": {
                "type": "object",
                "description": "Additional custom parameters as key-value pairs",
            },
            "output_file": {
                "type": "string",
                "description": "Optional file path to save the .scad file",
            },
        },
        "required": ["description"],
    }

    # Templates for common models
    TEMPLATES = {
        "box": '''// Parametric Box with Lid
// Generated by Sindri OpenSCAD Tools

// Parameters
{params}

// Box dimensions
box_inner_width = width - 2 * wall;
box_inner_depth = depth - 2 * wall;
box_inner_height = height - wall;

// Main box
module box() {{
    difference() {{
        cube([width, depth, height]);
        translate([wall, wall, wall])
            cube([box_inner_width, box_inner_depth, box_inner_height + 1]);
    }}
}}

// Lid
module lid() {{
    lid_height = wall * 2;
    lip = 1; // Lip that fits inside box

    union() {{
        // Top
        cube([width, depth, wall]);
        // Lip
        translate([wall - lip/2, wall - lip/2, -lip])
            cube([box_inner_width + lip, box_inner_depth + lip, lip]);
    }}
}}

// Render
box();
translate([width + 10, 0, 0]) lid();
''',
        "phone_stand": '''// Parametric Phone Stand
// Generated by Sindri OpenSCAD Tools

// Parameters
{params}

// Calculated values
stand_depth = phone_thickness + wall * 2 + 10;
stand_height = sin(angle) * phone_height * 0.4;
back_height = stand_height / sin(angle);

module phone_stand() {{
    difference() {{
        union() {{
            // Base
            cube([base_width, stand_depth, wall]);

            // Back support
            translate([0, stand_depth - wall, 0])
                rotate([90 - angle, 0, 0])
                    cube([base_width, back_height, wall]);

            // Phone rest lip
            translate([0, 0, 0])
                cube([base_width, wall * 2, lip_height]);
        }}

        // Cable channel (optional)
        if (cable_channel) {{
            translate([base_width/2 - 5, -1, -1])
                cube([10, stand_depth, wall + 2]);
        }}
    }}
}}

phone_stand();
''',
        "gear": '''// Parametric Involute Gear
// Generated by Sindri OpenSCAD Tools

// Parameters
{params}

// Calculated values
pitch_diameter = teeth * module_size;
outer_diameter = pitch_diameter + 2 * module_size;
root_diameter = pitch_diameter - 2.5 * module_size;
tooth_width = PI * module_size / 2;

module gear_tooth() {{
    linear_extrude(height = thickness) {{
        polygon(points = [
            [root_diameter/2, -tooth_width/4],
            [outer_diameter/2, -tooth_width/6],
            [outer_diameter/2, tooth_width/6],
            [root_diameter/2, tooth_width/4]
        ]);
    }}
}}

module gear() {{
    union() {{
        // Hub
        difference() {{
            cylinder(h = thickness, d = root_diameter, $fn = 64);
            translate([0, 0, -1])
                cylinder(h = thickness + 2, d = bore_diameter, $fn = 32);
        }}

        // Teeth
        for (i = [0:teeth-1]) {{
            rotate([0, 0, i * 360/teeth])
                gear_tooth();
        }}
    }}
}}

gear();
''',
        "enclosure": '''// Parametric Electronics Enclosure
// Generated by Sindri OpenSCAD Tools

// Parameters
{params}

// Calculated values
inner_width = width - 2 * wall;
inner_depth = depth - 2 * wall;
inner_height = height - wall;
screw_inset = wall + 3;

module enclosure_base() {{
    difference() {{
        // Outer shell
        cube([width, depth, height]);

        // Inner cavity
        translate([wall, wall, wall])
            cube([inner_width, inner_depth, inner_height + 1]);

        // Ventilation slots (optional)
        if (ventilation) {{
            for (i = [0:4]) {{
                translate([wall + 10 + i*12, -1, height - 15])
                    cube([8, wall + 2, 10]);
            }}
        }}
    }}

    // Screw posts
    if (screw_posts) {{
        for (pos = [[screw_inset, screw_inset],
                    [width - screw_inset, screw_inset],
                    [screw_inset, depth - screw_inset],
                    [width - screw_inset, depth - screw_inset]]) {{
            translate([pos[0], pos[1], wall])
                difference() {{
                    cylinder(h = height - wall - 2, d = 6, $fn = 24);
                    translate([0, 0, -1])
                        cylinder(h = height, d = screw_diameter, $fn = 16);
                }}
        }}
    }}
}}

module enclosure_lid() {{
    lid_lip = 1.5;

    difference() {{
        union() {{
            // Top
            cube([width, depth, wall]);

            // Inner lip
            translate([wall - lid_lip/2, wall - lid_lip/2, -lid_lip])
                difference() {{
                    cube([inner_width + lid_lip, inner_depth + lid_lip, lid_lip]);
                    translate([lid_lip, lid_lip, -1])
                        cube([inner_width - lid_lip, inner_depth - lid_lip, lid_lip + 2]);
                }}
        }}

        // Screw holes
        if (screw_posts) {{
            for (pos = [[screw_inset, screw_inset],
                        [width - screw_inset, screw_inset],
                        [screw_inset, depth - screw_inset],
                        [width - screw_inset, depth - screw_inset]]) {{
                translate([pos[0], pos[1], -1])
                    cylinder(h = wall + 2, d = screw_diameter + 0.5, $fn = 16);
            }}
        }}
    }}
}}

// Render both parts
enclosure_base();
translate([width + 10, 0, 0]) enclosure_lid();
''',
    }

    async def execute(
        self,
        description: str,
        parametric: bool = True,
        include_comments: bool = True,
        units: str = "mm",
        width: Optional[float] = None,
        height: Optional[float] = None,
        depth: Optional[float] = None,
        wall_thickness: float = 2.0,
        custom_params: Optional[dict] = None,
        output_file: Optional[str] = None,
        **kwargs,
    ) -> ToolResult:
        """Generate OpenSCAD code from description."""
        try:
            # Detect model type from description
            desc_lower = description.lower()
            template_type = None

            if any(x in desc_lower for x in ["box", "container", "case"]) and "lid" in desc_lower:
                template_type = "box"
            elif any(x in desc_lower for x in ["phone stand", "tablet stand", "stand"]) and any(x in desc_lower for x in ["angle", "degree"]):
                template_type = "phone_stand"
            elif "gear" in desc_lower and any(x in desc_lower for x in ["teeth", "tooth"]):
                template_type = "gear"
            elif any(x in desc_lower for x in ["enclosure", "case", "box"]) and any(x in desc_lower for x in ["electronics", "raspberry", "arduino", "pcb"]):
                template_type = "enclosure"

            if template_type:
                scad_code = self._generate_from_template(
                    template_type,
                    description,
                    width=width,
                    height=height,
                    depth=depth,
                    wall_thickness=wall_thickness,
                    custom_params=custom_params,
                    include_comments=include_comments,
                    units=units,
                )
            else:
                scad_code = self._generate_generic(
                    description,
                    parametric=parametric,
                    include_comments=include_comments,
                    width=width,
                    height=height,
                    depth=depth,
                    wall_thickness=wall_thickness,
                    custom_params=custom_params,
                    units=units,
                )

            if output_file:
                output_path = self._resolve_path(output_file)
                output_path.parent.mkdir(parents=True, exist_ok=True)
                output_path.write_text(scad_code)
                return ToolResult(
                    success=True,
                    output=f"OpenSCAD model saved to {output_path}\n\n```scad\n{scad_code}\n```",
                    metadata={
                        "template": template_type,
                        "output_file": str(output_path),
                        "units": units,
                    },
                )

            return ToolResult(
                success=True,
                output=f"```scad\n{scad_code}\n```",
                metadata={"template": template_type, "units": units},
            )

        except Exception as e:
            log.error("scad_generation_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Failed to generate OpenSCAD model: {str(e)}",
            )

    def _generate_from_template(
        self,
        template_type: str,
        description: str,
        width: Optional[float],
        height: Optional[float],
        depth: Optional[float],
        wall_thickness: float,
        custom_params: Optional[dict],
        include_comments: bool,
        units: str,
    ) -> str:
        """Generate code from a template."""
        template = self.TEMPLATES[template_type]

        # Build parameters based on template type
        params_lines = []

        if template_type == "box":
            w = width or 50
            h = height or 30
            d = depth or 40
            params_lines = [
                f"width = {w};  // Width in {units}",
                f"height = {h};  // Height in {units}",
                f"depth = {d};  // Depth in {units}",
                f"wall = {wall_thickness};  // Wall thickness in {units}",
            ]

        elif template_type == "phone_stand":
            # Extract angle from description
            angle_match = re.search(r"(\d+)\s*(?:degree|°|deg)", description.lower())
            angle = int(angle_match.group(1)) if angle_match else 60

            params_lines = [
                f"angle = {angle};  // Stand angle in degrees",
                f"phone_height = {height or 150};  // Phone height in {units}",
                f"phone_thickness = {depth or 12};  // Phone thickness in {units}",
                f"base_width = {width or 80};  // Base width in {units}",
                f"wall = {wall_thickness};  // Wall thickness in {units}",
                f"lip_height = 10;  // Height of phone rest lip",
                "cable_channel = true;  // Include cable routing channel",
            ]

        elif template_type == "gear":
            # Extract teeth from description
            teeth_match = re.search(r"(\d+)\s*teeth", description.lower())
            teeth = int(teeth_match.group(1)) if teeth_match else 24

            # Extract module from description
            module_match = re.search(r"module\s*(?:=|:)?\s*([\d.]+)", description.lower())
            gear_module = float(module_match.group(1)) if module_match else 1.5

            params_lines = [
                f"teeth = {teeth};  // Number of teeth",
                f"module_size = {gear_module};  // Gear module",
                f"thickness = {height or 5};  // Gear thickness in {units}",
                f"bore_diameter = {custom_params.get('bore', 5) if custom_params else 5};  // Center bore diameter",
                "PI = 3.14159265359;",
            ]

        elif template_type == "enclosure":
            w = width or 100
            h = height or 40
            d = depth or 80
            params_lines = [
                f"width = {w};  // Width in {units}",
                f"height = {h};  // Height in {units}",
                f"depth = {d};  // Depth in {units}",
                f"wall = {wall_thickness};  // Wall thickness in {units}",
                "ventilation = true;  // Include ventilation slots",
                "screw_posts = true;  // Include screw mounting posts",
                "screw_diameter = 3;  // M3 screws",
            ]

        # Add any custom parameters
        if custom_params:
            for key, value in custom_params.items():
                if not any(key in line for line in params_lines):
                    if isinstance(value, str):
                        params_lines.append(f'{key} = "{value}";')
                    elif isinstance(value, bool):
                        params_lines.append(f"{key} = {'true' if value else 'false'};")
                    else:
                        params_lines.append(f"{key} = {value};")

        params_str = "\n".join(params_lines)
        return template.format(params=params_str)

    def _generate_generic(
        self,
        description: str,
        parametric: bool,
        include_comments: bool,
        width: Optional[float],
        height: Optional[float],
        depth: Optional[float],
        wall_thickness: float,
        custom_params: Optional[dict],
        units: str,
    ) -> str:
        """Generate generic OpenSCAD code from description."""
        lines = []

        if include_comments:
            lines.extend([
                f"// {description}",
                "// Generated by Sindri OpenSCAD Tools",
                "",
            ])

        # Add parameters
        if parametric:
            lines.append("// Parameters")
            if width:
                lines.append(f"width = {width};  // in {units}")
            if height:
                lines.append(f"height = {height};  // in {units}")
            if depth:
                lines.append(f"depth = {depth};  // in {units}")
            lines.append(f"wall = {wall_thickness};  // Wall thickness in {units}")

            if custom_params:
                for key, value in custom_params.items():
                    if isinstance(value, str):
                        lines.append(f'{key} = "{value}";')
                    elif isinstance(value, bool):
                        lines.append(f"{key} = {'true' if value else 'false'};")
                    else:
                        lines.append(f"{key} = {value};")

            lines.append("")

        # Generate basic shape based on description
        desc_lower = description.lower()

        # Create a main module
        lines.append("module main() {")

        if "hollow" in desc_lower or "shell" in desc_lower:
            lines.append("    difference() {")
            lines.append(f"        cube([{width or 50}, {depth or 50}, {height or 50}]);")
            lines.append(f"        translate([wall, wall, wall])")
            lines.append(f"            cube([{(width or 50) - 2*wall_thickness}, {(depth or 50) - 2*wall_thickness}, {(height or 50) - wall_thickness + 1}]);")
            lines.append("    }")
        elif "cylinder" in desc_lower or "tube" in desc_lower or "round" in desc_lower:
            radius = (width or 50) / 2
            lines.append(f"    cylinder(h = {height or 50}, r = {radius}, $fn = 64);")
        elif "sphere" in desc_lower or "ball" in desc_lower:
            radius = (width or 50) / 2
            lines.append(f"    sphere(r = {radius}, $fn = 64);")
        else:
            # Default to cube
            lines.append(f"    cube([{width or 50}, {depth or 50}, {height or 50}]);")

        lines.append("}")
        lines.append("")
        lines.append("// Render")
        lines.append("main();")

        return "\n".join(lines)


class RenderPreviewTool(Tool):
    """Render an OpenSCAD model to PNG or STL preview.

    Requires OpenSCAD to be installed on the system.
    """

    name = "render_preview"
    description = """Render an OpenSCAD model to PNG image or STL preview.

Requires OpenSCAD to be installed on the system.

Examples:
- render_preview(input_file="model.scad", format="png")
- render_preview(input_file="model.scad", format="stl", output_file="preview.stl")
- render_preview(input_file="model.scad", format="png", camera="0,0,0,0,0,0,200")"""

    parameters = {
        "type": "object",
        "properties": {
            "input_file": {
                "type": "string",
                "description": "Path to .scad file to render",
            },
            "format": {
                "type": "string",
                "description": "Output format (png for image, stl for mesh)",
                "enum": ["png", "stl"],
            },
            "output_file": {
                "type": "string",
                "description": "Output file path (auto-generated if not specified)",
            },
            "camera": {
                "type": "string",
                "description": "Camera position as 'tx,ty,tz,rx,ry,rz,dist' or preset",
            },
            "image_size": {
                "type": "string",
                "description": "Image size as 'width,height' (default: 800,600)",
            },
            "colorscheme": {
                "type": "string",
                "description": "Color scheme for rendering",
                "enum": ["Cornfield", "Metallic", "Sunset", "Starnight", "BeforeDawn", "Nature", "DeepOcean"],
            },
        },
        "required": ["input_file"],
    }

    async def execute(
        self,
        input_file: str,
        format: str = "png",
        output_file: Optional[str] = None,
        camera: Optional[str] = None,
        image_size: str = "800,600",
        colorscheme: str = "Cornfield",
        **kwargs,
    ) -> ToolResult:
        """Render OpenSCAD model."""
        try:
            input_path = self._resolve_path(input_file)
            if not input_path.exists():
                return ToolResult(
                    success=False,
                    output="",
                    error=f"Input file not found: {input_path}",
                )

            # Check if OpenSCAD is installed
            try:
                result = subprocess.run(
                    ["openscad", "--version"],
                    capture_output=True,
                    timeout=10,
                )
                if result.returncode != 0:
                    return ToolResult(
                        success=False,
                        output="",
                        error="OpenSCAD not found. Please install OpenSCAD to render models.",
                    )
            except FileNotFoundError:
                return ToolResult(
                    success=False,
                    output="",
                    error="OpenSCAD not found. Please install OpenSCAD (https://openscad.org).",
                )

            # Determine output file
            if output_file:
                out_path = self._resolve_path(output_file)
            else:
                out_path = input_path.with_suffix(f".{format}")

            out_path.parent.mkdir(parents=True, exist_ok=True)

            # Build command
            cmd = ["openscad", "-o", str(out_path)]

            if format == "png":
                width, height = image_size.split(",")
                cmd.extend(["--imgsize", width, height])
                cmd.extend(["--colorscheme", colorscheme])

                if camera:
                    cmd.extend(["--camera", camera])
                else:
                    # Auto-center camera
                    cmd.append("--autocenter")
                    cmd.append("--viewall")

            cmd.append(str(input_path))

            # Run OpenSCAD
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout for complex models
            )

            if result.returncode != 0:
                return ToolResult(
                    success=False,
                    output=result.stdout,
                    error=f"OpenSCAD rendering failed: {result.stderr}",
                )

            if out_path.exists():
                return ToolResult(
                    success=True,
                    output=f"Rendered {format.upper()} to {out_path}",
                    metadata={
                        "output_file": str(out_path),
                        "format": format,
                        "size_bytes": out_path.stat().st_size,
                    },
                )
            else:
                return ToolResult(
                    success=False,
                    output="",
                    error="Rendering completed but output file not created",
                )

        except subprocess.TimeoutExpired:
            return ToolResult(
                success=False,
                output="",
                error="OpenSCAD rendering timed out (>5 minutes)",
            )
        except Exception as e:
            log.error("render_preview_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Failed to render preview: {str(e)}",
            )


class ExportSTLTool(Tool):
    """Export an OpenSCAD model to STL for 3D printing.

    Requires OpenSCAD to be installed on the system.
    """

    name = "export_stl"
    description = """Export an OpenSCAD model to STL format for 3D printing.

Requires OpenSCAD to be installed.

Features:
- Export to binary or ASCII STL
- Set resolution/quality ($fn value)
- Validate manifold geometry

Examples:
- export_stl(input_file="model.scad", output_file="model.stl")
- export_stl(input_file="model.scad", quality="high")
- export_stl(input_file="model.scad", ascii=True)"""

    parameters = {
        "type": "object",
        "properties": {
            "input_file": {
                "type": "string",
                "description": "Path to .scad file to export",
            },
            "output_file": {
                "type": "string",
                "description": "Output STL file path",
            },
            "quality": {
                "type": "string",
                "description": "Render quality (affects $fn for curved surfaces)",
                "enum": ["draft", "normal", "high", "ultra"],
            },
            "ascii": {
                "type": "boolean",
                "description": "Export as ASCII STL instead of binary (larger file)",
            },
        },
        "required": ["input_file"],
    }

    QUALITY_SETTINGS = {
        "draft": 16,
        "normal": 32,
        "high": 64,
        "ultra": 128,
    }

    async def execute(
        self,
        input_file: str,
        output_file: Optional[str] = None,
        quality: str = "normal",
        ascii: bool = False,
        **kwargs,
    ) -> ToolResult:
        """Export OpenSCAD model to STL."""
        try:
            input_path = self._resolve_path(input_file)
            if not input_path.exists():
                return ToolResult(
                    success=False,
                    output="",
                    error=f"Input file not found: {input_path}",
                )

            # Check if OpenSCAD is installed
            try:
                subprocess.run(["openscad", "--version"], capture_output=True, timeout=10)
            except FileNotFoundError:
                return ToolResult(
                    success=False,
                    output="",
                    error="OpenSCAD not found. Please install OpenSCAD.",
                )

            # Determine output file
            if output_file:
                out_path = self._resolve_path(output_file)
            else:
                out_path = input_path.with_suffix(".stl")

            out_path.parent.mkdir(parents=True, exist_ok=True)

            # Build command
            fn_value = self.QUALITY_SETTINGS.get(quality, 32)
            cmd = [
                "openscad",
                "-o", str(out_path),
                "-D", f"$fn={fn_value}",
            ]

            cmd.append(str(input_path))

            # Run OpenSCAD
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minute timeout
            )

            if result.returncode != 0:
                return ToolResult(
                    success=False,
                    output=result.stdout,
                    error=f"STL export failed: {result.stderr}",
                )

            if out_path.exists():
                size = out_path.stat().st_size
                size_str = f"{size / 1024:.1f} KB" if size < 1024 * 1024 else f"{size / 1024 / 1024:.1f} MB"

                return ToolResult(
                    success=True,
                    output=f"Exported STL to {out_path} ({size_str})",
                    metadata={
                        "output_file": str(out_path),
                        "quality": quality,
                        "fn_value": fn_value,
                        "size_bytes": size,
                    },
                )
            else:
                return ToolResult(
                    success=False,
                    output="",
                    error="Export completed but STL file not created",
                )

        except subprocess.TimeoutExpired:
            return ToolResult(
                success=False,
                output="",
                error="STL export timed out (>10 minutes). Try 'draft' quality.",
            )
        except Exception as e:
            log.error("export_stl_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Failed to export STL: {str(e)}",
            )


class ValidateSCADTool(Tool):
    """Validate OpenSCAD code for syntax and geometry issues.

    Checks for common problems that cause print failures.
    """

    name = "validate_scad"
    description = """Validate OpenSCAD code for syntax and geometry issues.

Checks for:
- Syntax errors
- Non-manifold geometry (holes, overlapping faces)
- Common design mistakes
- Undefined variables

Examples:
- validate_scad(input_file="model.scad")
- validate_scad(code="cube([10,10,10]);")"""

    parameters = {
        "type": "object",
        "properties": {
            "input_file": {
                "type": "string",
                "description": "Path to .scad file to validate",
            },
            "code": {
                "type": "string",
                "description": "OpenSCAD code to validate (alternative to file)",
            },
        },
    }

    async def execute(
        self,
        input_file: Optional[str] = None,
        code: Optional[str] = None,
        **kwargs,
    ) -> ToolResult:
        """Validate OpenSCAD code."""
        try:
            if not input_file and not code:
                return ToolResult(
                    success=False,
                    output="",
                    error="Either input_file or code must be provided",
                )

            # Get code content
            if input_file:
                input_path = self._resolve_path(input_file)
                if not input_path.exists():
                    return ToolResult(
                        success=False,
                        output="",
                        error=f"File not found: {input_path}",
                    )
                code = input_path.read_text()

            issues = []

            # Static analysis
            issues.extend(self._check_syntax(code))
            issues.extend(self._check_common_issues(code))

            # Try to compile with OpenSCAD if available
            try:
                compile_issues = await self._compile_check(code)
                issues.extend(compile_issues)
            except FileNotFoundError:
                issues.append(PrintabilityIssue(
                    severity="warning",
                    issue_type="openscad_not_installed",
                    description="OpenSCAD not found - could not perform compile check",
                    suggestion="Install OpenSCAD for full validation",
                ))

            # Format results
            errors = [i for i in issues if i.severity == "error"]
            warnings = [i for i in issues if i.severity == "warning"]

            result_lines = []
            if errors:
                result_lines.append(f"❌ {len(errors)} error(s) found:")
                for err in errors:
                    result_lines.append(f"  [{err.issue_type}] {err.description}")
                    if err.suggestion:
                        result_lines.append(f"    → {err.suggestion}")

            if warnings:
                result_lines.append(f"⚠️  {len(warnings)} warning(s) found:")
                for warn in warnings:
                    result_lines.append(f"  [{warn.issue_type}] {warn.description}")
                    if warn.suggestion:
                        result_lines.append(f"    → {warn.suggestion}")

            if not errors and not warnings:
                result_lines.append("✅ No issues found!")

            return ToolResult(
                success=len(errors) == 0,
                output="\n".join(result_lines),
                metadata={
                    "errors": len(errors),
                    "warnings": len(warnings),
                    "issues": [{"type": i.issue_type, "severity": i.severity, "description": i.description} for i in issues],
                },
            )

        except Exception as e:
            log.error("validate_scad_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Validation failed: {str(e)}",
            )

    def _check_syntax(self, code: str) -> list[PrintabilityIssue]:
        """Check for basic syntax issues."""
        issues = []

        # Check for unbalanced braces
        open_braces = code.count("{") - code.count("}")
        if open_braces != 0:
            issues.append(PrintabilityIssue(
                severity="error",
                issue_type="unbalanced_braces",
                description=f"Unbalanced braces: {abs(open_braces)} {'extra {' if open_braces > 0 else 'extra }'}",
                suggestion="Check for missing or extra curly braces",
            ))

        # Check for unbalanced brackets
        open_brackets = code.count("[") - code.count("]")
        if open_brackets != 0:
            issues.append(PrintabilityIssue(
                severity="error",
                issue_type="unbalanced_brackets",
                description=f"Unbalanced brackets: {abs(open_brackets)} {'extra [' if open_brackets > 0 else 'extra ]'}",
                suggestion="Check for missing or extra square brackets",
            ))

        # Check for unbalanced parentheses
        open_parens = code.count("(") - code.count(")")
        if open_parens != 0:
            issues.append(PrintabilityIssue(
                severity="error",
                issue_type="unbalanced_parentheses",
                description=f"Unbalanced parentheses: {abs(open_parens)} {'extra (' if open_parens > 0 else 'extra )'}",
                suggestion="Check for missing or extra parentheses",
            ))

        # Check for missing semicolons (basic check)
        lines = code.split("\n")
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            if stripped and not stripped.startswith("//") and not stripped.startswith("/*"):
                # Lines that should end with semicolon or brace
                if stripped and not stripped.endswith((";", "{", "}", "/", "*")):
                    if not any(stripped.startswith(kw) for kw in ["module", "function", "if", "else", "for", "let"]):
                        # Could be missing semicolon
                        pass  # This is too noisy, skip for now

        return issues

    def _check_common_issues(self, code: str) -> list[PrintabilityIssue]:
        """Check for common design issues."""
        issues = []

        # Check for zero-dimension primitives
        zero_patterns = [
            (r"cube\s*\(\s*\[?\s*0", "Zero-dimension cube"),
            (r"cylinder\s*\([^)]*h\s*=\s*0", "Zero-height cylinder"),
            (r"cylinder\s*\([^)]*r\s*=\s*0", "Zero-radius cylinder"),
            (r"sphere\s*\([^)]*r\s*=\s*0", "Zero-radius sphere"),
        ]

        for pattern, desc in zero_patterns:
            if re.search(pattern, code):
                issues.append(PrintabilityIssue(
                    severity="error",
                    issue_type="zero_dimension",
                    description=desc,
                    suggestion="All dimensions must be positive values",
                ))

        # Check for $fn too low for smooth curves
        fn_match = re.search(r"\$fn\s*=\s*(\d+)", code)
        if fn_match:
            fn_value = int(fn_match.group(1))
            if fn_value < 16:
                issues.append(PrintabilityIssue(
                    severity="warning",
                    issue_type="low_resolution",
                    description=f"$fn={fn_value} is low - curves will be faceted",
                    suggestion="Use $fn >= 32 for smooth curves in prints",
                ))

        # Check for very thin walls
        wall_match = re.search(r"wall\s*=\s*([\d.]+)", code)
        if wall_match:
            wall = float(wall_match.group(1))
            if wall < 0.8:
                issues.append(PrintabilityIssue(
                    severity="warning",
                    issue_type="thin_wall",
                    description=f"Wall thickness {wall}mm may be too thin for printing",
                    suggestion="Use wall thickness >= 0.8mm for reliable prints",
                ))

        # Check for difference with no subtraction
        diff_matches = list(re.finditer(r"difference\s*\(\s*\)\s*\{([^}]*)\}", code, re.DOTALL))
        for match in diff_matches:
            content = match.group(1)
            # Count top-level operations (rough check)
            operations = len(re.findall(r"(?:cube|cylinder|sphere|translate|rotate|scale|union|difference|intersection|linear_extrude|rotate_extrude)\s*\(", content))
            if operations < 2:
                issues.append(PrintabilityIssue(
                    severity="warning",
                    issue_type="empty_difference",
                    description="difference() with less than 2 children has no effect",
                    suggestion="difference() needs at least 2 shapes to subtract from",
                ))

        return issues

    async def _compile_check(self, code: str) -> list[PrintabilityIssue]:
        """Compile with OpenSCAD to check for errors."""
        issues = []

        with tempfile.NamedTemporaryFile(mode="w", suffix=".scad", delete=False) as f:
            f.write(code)
            temp_scad = Path(f.name)

        try:
            with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as f:
                temp_stl = Path(f.name)

            result = subprocess.run(
                ["openscad", "-o", str(temp_stl), str(temp_scad)],
                capture_output=True,
                text=True,
                timeout=60,
            )

            # Parse OpenSCAD output for errors and warnings
            output = result.stderr + result.stdout

            if "ERROR:" in output or "error:" in output.lower():
                for line in output.split("\n"):
                    if "ERROR:" in line or "error:" in line.lower():
                        issues.append(PrintabilityIssue(
                            severity="error",
                            issue_type="compile_error",
                            description=line.strip(),
                            suggestion="Fix the syntax error and try again",
                        ))

            if "WARNING:" in output:
                for line in output.split("\n"):
                    if "WARNING:" in line:
                        # Skip certain noisy warnings
                        if "Normalized OBJ" not in line:
                            issues.append(PrintabilityIssue(
                                severity="warning",
                                issue_type="compile_warning",
                                description=line.strip(),
                                suggestion="Review the warning and fix if needed",
                            ))

            temp_stl.unlink(missing_ok=True)

        finally:
            temp_scad.unlink(missing_ok=True)

        return issues


class ParametrizeTool(Tool):
    """Convert hardcoded values in OpenSCAD code to parameters.

    Makes models more reusable and customizable.
    """

    name = "parametrize_model"
    description = """Convert hardcoded numeric values in OpenSCAD code to parameters.

Makes models parametric and customizable.

Examples:
- parametrize_model(input_file="model.scad")
- parametrize_model(code="cube([50,30,40]);")"""

    parameters = {
        "type": "object",
        "properties": {
            "input_file": {
                "type": "string",
                "description": "Path to .scad file to parametrize",
            },
            "code": {
                "type": "string",
                "description": "OpenSCAD code to parametrize",
            },
            "output_file": {
                "type": "string",
                "description": "Output file path (modifies in place if not specified)",
            },
            "prefix": {
                "type": "string",
                "description": "Prefix for generated parameter names (default: none)",
            },
        },
    }

    async def execute(
        self,
        input_file: Optional[str] = None,
        code: Optional[str] = None,
        output_file: Optional[str] = None,
        prefix: str = "",
        **kwargs,
    ) -> ToolResult:
        """Parametrize OpenSCAD code."""
        try:
            if not input_file and not code:
                return ToolResult(
                    success=False,
                    output="",
                    error="Either input_file or code must be provided",
                )

            # Get code content
            if input_file:
                input_path = self._resolve_path(input_file)
                if not input_path.exists():
                    return ToolResult(
                        success=False,
                        output="",
                        error=f"File not found: {input_path}",
                    )
                code = input_path.read_text()

            # Find existing parameters
            existing_params = set(re.findall(r"^\s*(\w+)\s*=", code, re.MULTILINE))

            # Find hardcoded values and their contexts
            params = {}
            new_code = code

            # Pattern for cube dimensions
            cube_pattern = r"cube\s*\(\s*\[(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*\]"
            for match in re.finditer(cube_pattern, code):
                w, d, h = match.groups()
                width_var = f"{prefix}width" if prefix else "width"
                depth_var = f"{prefix}depth" if prefix else "depth"
                height_var = f"{prefix}height" if prefix else "height"

                if width_var not in existing_params:
                    params[width_var] = float(w)
                if depth_var not in existing_params:
                    params[depth_var] = float(d)
                if height_var not in existing_params:
                    params[height_var] = float(h)

                new_code = new_code.replace(
                    match.group(0),
                    f"cube([{width_var}, {depth_var}, {height_var}]",
                    1
                )

            # Pattern for cylinder
            cyl_pattern = r"cylinder\s*\(\s*h\s*=\s*(\d+(?:\.\d+)?)\s*,\s*r\s*=\s*(\d+(?:\.\d+)?)"
            for match in re.finditer(cyl_pattern, code):
                h, r = match.groups()
                height_var = f"{prefix}cyl_height" if prefix else "cyl_height"
                radius_var = f"{prefix}cyl_radius" if prefix else "cyl_radius"

                if height_var not in existing_params:
                    params[height_var] = float(h)
                if radius_var not in existing_params:
                    params[radius_var] = float(r)

            # Pattern for sphere
            sphere_pattern = r"sphere\s*\(\s*r\s*=\s*(\d+(?:\.\d+)?)"
            for match in re.finditer(sphere_pattern, code):
                r = match.group(1)
                radius_var = f"{prefix}sphere_radius" if prefix else "sphere_radius"
                if radius_var not in existing_params:
                    params[radius_var] = float(r)

            # Build new code with parameters section
            if params:
                param_lines = ["// Parameters (generated by Sindri)"]
                for name, value in sorted(params.items()):
                    if value == int(value):
                        param_lines.append(f"{name} = {int(value)};")
                    else:
                        param_lines.append(f"{name} = {value};")
                param_lines.append("")

                # Insert parameters at the beginning (after any initial comments)
                first_non_comment = 0
                lines = new_code.split("\n")
                for i, line in enumerate(lines):
                    stripped = line.strip()
                    if stripped and not stripped.startswith("//") and not stripped.startswith("/*"):
                        first_non_comment = i
                        break

                new_code = "\n".join(lines[:first_non_comment]) + "\n"
                new_code += "\n".join(param_lines)
                new_code += "\n".join(lines[first_non_comment:])

            # Save output
            if output_file:
                out_path = self._resolve_path(output_file)
            elif input_file:
                out_path = self._resolve_path(input_file)
            else:
                # Return code directly
                return ToolResult(
                    success=True,
                    output=f"Extracted {len(params)} parameters:\n\n```scad\n{new_code}\n```",
                    metadata={"parameters": params},
                )

            out_path.parent.mkdir(parents=True, exist_ok=True)
            out_path.write_text(new_code)

            return ToolResult(
                success=True,
                output=f"Parametrized model saved to {out_path}\n\nExtracted {len(params)} parameters:\n{', '.join(params.keys())}",
                metadata={"output_file": str(out_path), "parameters": params},
            )

        except Exception as e:
            log.error("parametrize_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Failed to parametrize model: {str(e)}",
            )


class OptimizePrintabilityTool(Tool):
    """Analyze and optimize OpenSCAD model for 3D printing.

    Suggests improvements for successful prints.
    """

    name = "optimize_printability"
    description = """Analyze an OpenSCAD model and suggest optimizations for 3D printing.

Checks for:
- Wall thickness (minimum printable)
- Overhangs requiring supports
- Print orientation suggestions
- Tolerance recommendations for fits
- Bridge lengths

Examples:
- optimize_printability(input_file="model.scad")
- optimize_printability(input_file="model.scad", nozzle_diameter=0.4)"""

    parameters = {
        "type": "object",
        "properties": {
            "input_file": {
                "type": "string",
                "description": "Path to .scad file to analyze",
            },
            "code": {
                "type": "string",
                "description": "OpenSCAD code to analyze",
            },
            "nozzle_diameter": {
                "type": "number",
                "description": "Printer nozzle diameter in mm (default: 0.4)",
            },
            "layer_height": {
                "type": "number",
                "description": "Layer height in mm (default: 0.2)",
            },
            "printer_type": {
                "type": "string",
                "description": "Printer type for specific recommendations",
                "enum": ["fdm", "sla", "sls"],
            },
        },
    }

    async def execute(
        self,
        input_file: Optional[str] = None,
        code: Optional[str] = None,
        nozzle_diameter: float = 0.4,
        layer_height: float = 0.2,
        printer_type: str = "fdm",
        **kwargs,
    ) -> ToolResult:
        """Analyze model for printability."""
        try:
            if not input_file and not code:
                return ToolResult(
                    success=False,
                    output="",
                    error="Either input_file or code must be provided",
                )

            if input_file:
                input_path = self._resolve_path(input_file)
                if not input_path.exists():
                    return ToolResult(
                        success=False,
                        output="",
                        error=f"File not found: {input_path}",
                    )
                code = input_path.read_text()

            suggestions = []
            warnings = []

            # Minimum wall thickness based on nozzle
            min_wall = nozzle_diameter * 2
            wall_match = re.search(r"wall\s*=\s*([\d.]+)", code)
            if wall_match:
                wall = float(wall_match.group(1))
                if wall < min_wall:
                    warnings.append(f"Wall thickness {wall}mm is less than recommended minimum {min_wall}mm (2x nozzle)")
                    suggestions.append(f"Increase wall thickness to at least {min_wall}mm")

            # Check for steep overhangs (angles in rotate)
            rotate_matches = re.finditer(r"rotate\s*\(\s*\[([^\]]+)\]", code)
            for match in rotate_matches:
                angles = [float(x.strip()) for x in match.group(1).split(",")]
                for angle in angles:
                    if abs(angle) > 45 and abs(angle) < 135 and abs(angle) != 90:
                        suggestions.append(f"Rotation of {angle}° may create overhangs requiring supports")

            # Check tolerance for fits
            if "fit" in code.lower() or "clearance" in code.lower() or "tolerance" in code.lower():
                suggestions.append("For press fits: use -0.1mm to -0.2mm interference")
                suggestions.append("For sliding fits: use +0.2mm to +0.4mm clearance")
                suggestions.append("For loose fits: use +0.4mm to +0.8mm clearance")

            # FDM-specific suggestions
            if printer_type == "fdm":
                # Check for small details
                small_patterns = [
                    (r"r\s*=\s*(0\.[0-3])", "Very small radius may not print well on FDM"),
                    (r"cylinder\s*\([^)]*d\s*=\s*(0\.[0-7])", "Cylinders under 0.8mm may fail on FDM"),
                ]
                for pattern, msg in small_patterns:
                    if re.search(pattern, code):
                        warnings.append(msg)

                # Suggest elephant foot compensation
                if "cube" in code or "cylinder" in code:
                    suggestions.append("Consider adding 0.2mm chamfer at bottom edges to compensate for elephant foot")

                # Bridge detection
                if "difference" in code:
                    suggestions.append("Check for bridges over 10mm - may need supports or bridging optimization")

            # SLA-specific suggestions
            elif printer_type == "sla":
                suggestions.append("Add drainage holes for hollow prints to prevent suction and trapped resin")
                suggestions.append("Consider print orientation to minimize support contact with visible surfaces")
                suggestions.append("Minimum feature size: 0.1mm")

            # General suggestions
            if "screw" in code.lower() or "bolt" in code.lower() or "thread" in code.lower():
                suggestions.append("For printed threads: use 0.3mm clearance and consider tap/die finishing")

            if "hinge" in code.lower() or "joint" in code.lower():
                suggestions.append("Print-in-place hinges need 0.3-0.5mm gap between parts")

            # Build report
            report_lines = [f"🔧 Printability Analysis ({printer_type.upper()})"]
            report_lines.append(f"   Nozzle: {nozzle_diameter}mm | Layer: {layer_height}mm")
            report_lines.append("")

            if warnings:
                report_lines.append("⚠️  Warnings:")
                for w in warnings:
                    report_lines.append(f"  • {w}")
                report_lines.append("")

            if suggestions:
                report_lines.append("💡 Suggestions:")
                for s in suggestions:
                    report_lines.append(f"  • {s}")
            else:
                report_lines.append("✅ No major printability issues detected!")

            # Print settings recommendations
            report_lines.append("")
            report_lines.append("🖨️  Recommended Print Settings:")
            report_lines.append(f"  • Layer height: {layer_height}mm")
            report_lines.append(f"  • Wall line count: {max(2, int(min_wall / nozzle_diameter))}")
            report_lines.append("  • Infill: 20-40% for structural parts")
            report_lines.append("  • Supports: Check preview for overhangs > 45°")

            return ToolResult(
                success=True,
                output="\n".join(report_lines),
                metadata={
                    "warnings": len(warnings),
                    "suggestions": len(suggestions),
                    "printer_type": printer_type,
                    "nozzle_diameter": nozzle_diameter,
                    "layer_height": layer_height,
                },
            )

        except Exception as e:
            log.error("optimize_printability_failed", error=str(e))
            return ToolResult(
                success=False,
                output="",
                error=f"Failed to analyze printability: {str(e)}",
            )
