"""Tests for OpenSCAD 3D modeling tools (Phase 11)."""

import pytest
import tempfile
from pathlib import Path

from sindri.tools.openscad import (
    GenerateSCADTool,
    RenderPreviewTool,
    ExportSTLTool,
    ValidateSCADTool,
    ParametrizeTool,
    OptimizePrintabilityTool,
)


# ═══════════════════════════════════════════════════════════════════════════════
# GenerateSCADTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestGenerateSCADTool:
    """Test suite for OpenSCAD code generation."""

    @pytest.fixture
    def tool(self):
        return GenerateSCADTool()

    @pytest.mark.asyncio
    async def test_basic_generation(self, tool):
        """Test basic code generation."""
        result = await tool.execute(
            description="A simple box",
            width=50,
            height=30,
            depth=40,
        )

        assert result.success
        assert "cube" in result.output.lower() or "module" in result.output.lower()
        assert result.metadata is not None

    @pytest.mark.asyncio
    async def test_box_with_lid_template(self, tool):
        """Test box with lid template detection."""
        result = await tool.execute(
            description="A box with a lid",
            width=50,
            height=30,
            depth=40,
        )

        assert result.success
        assert "box" in result.output.lower()
        assert "lid" in result.output.lower()
        assert "difference()" in result.output or "difference" in result.output

    @pytest.mark.asyncio
    async def test_phone_stand_template(self, tool):
        """Test phone stand template detection."""
        result = await tool.execute(
            description="Phone stand with 60 degree angle",
        )

        assert result.success
        assert "angle" in result.output.lower()
        assert "60" in result.output
        assert result.metadata.get("template") == "phone_stand"

    @pytest.mark.asyncio
    async def test_gear_template(self, tool):
        """Test gear template detection."""
        result = await tool.execute(
            description="Gear with 24 teeth",
        )

        assert result.success
        assert "teeth" in result.output.lower()
        assert "24" in result.output
        assert result.metadata.get("template") == "gear"

    @pytest.mark.asyncio
    async def test_enclosure_template(self, tool):
        """Test electronics enclosure template detection."""
        result = await tool.execute(
            description="Enclosure for Raspberry Pi",
            width=100,
            height=40,
            depth=80,
        )

        assert result.success
        assert "enclosure" in result.output.lower() or "screw" in result.output.lower()
        assert result.metadata.get("template") == "enclosure"

    @pytest.mark.asyncio
    async def test_custom_wall_thickness(self, tool):
        """Test custom wall thickness."""
        result = await tool.execute(
            description="A box with lid",
            width=50,
            height=30,
            depth=40,
            wall_thickness=3.0,
        )

        assert result.success
        assert "3" in result.output or "wall" in result.output.lower()

    @pytest.mark.asyncio
    async def test_output_to_file(self, tool):
        """Test saving to file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_file = Path(tmpdir) / "model.scad"

            result = await tool.execute(
                description="A simple box",
                width=50,
                height=30,
                depth=40,
                output_file=str(output_file),
            )

            assert result.success
            assert output_file.exists()
            content = output_file.read_text()
            assert len(content) > 0

    @pytest.mark.asyncio
    async def test_units_metadata(self, tool):
        """Test that units are tracked in metadata."""
        result = await tool.execute(
            description="A box",
            units="mm",
        )

        assert result.success
        assert result.metadata.get("units") == "mm"

    @pytest.mark.asyncio
    async def test_includes_comments_default(self, tool):
        """Test that comments are included by default."""
        result = await tool.execute(
            description="A simple box",
        )

        assert result.success
        assert "//" in result.output

    @pytest.mark.asyncio
    async def test_parametric_default(self, tool):
        """Test that parametric variables are generated by default."""
        result = await tool.execute(
            description="A box",
            width=50,
            height=30,
        )

        assert result.success
        # Should contain variable assignments
        assert "=" in result.output

    @pytest.mark.asyncio
    async def test_custom_params(self, tool):
        """Test custom parameters are included."""
        result = await tool.execute(
            description="A gear with 24 teeth",
            custom_params={"bore": 8},
        )

        assert result.success
        # Custom bore parameter should be in output
        # Note: may be named differently in the template

    @pytest.mark.asyncio
    async def test_generic_generation_hollow(self, tool):
        """Test generic generation for hollow objects."""
        result = await tool.execute(
            description="A hollow cylinder tube",
            width=30,
            height=50,
        )

        assert result.success
        assert "cylinder" in result.output.lower()

    @pytest.mark.asyncio
    async def test_generic_generation_sphere(self, tool):
        """Test generic generation for sphere."""
        result = await tool.execute(
            description="A sphere ball",
            width=40,
        )

        assert result.success
        assert "sphere" in result.output.lower()


# ═══════════════════════════════════════════════════════════════════════════════
# RenderPreviewTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestRenderPreviewTool:
    """Test suite for OpenSCAD preview rendering."""

    @pytest.fixture
    def tool(self):
        return RenderPreviewTool()

    @pytest.fixture
    def sample_scad_file(self, tmp_path):
        """Create a sample .scad file for testing."""
        content = """// Test model
cube([10, 10, 10]);
"""
        file_path = tmp_path / "test.scad"
        file_path.write_text(content)
        return file_path

    @pytest.mark.asyncio
    async def test_file_not_found(self, tool):
        """Test handling of non-existent file."""
        result = await tool.execute(
            input_file="/nonexistent/file.scad",
        )

        assert not result.success
        assert "not found" in result.error.lower()

    @pytest.mark.asyncio
    async def test_openscad_not_installed(self, tool, sample_scad_file):
        """Test handling when OpenSCAD is not installed."""
        # This test may pass or fail depending on whether OpenSCAD is installed
        # The important thing is it doesn't crash
        result = await tool.execute(
            input_file=str(sample_scad_file),
            format="png",
        )

        # Either succeeds or fails with appropriate error
        if not result.success:
            assert "openscad" in result.error.lower()

    @pytest.mark.asyncio
    async def test_default_format_is_png(self, tool, sample_scad_file):
        """Test that default format is PNG."""
        # Just verify the parameters work
        result = await tool.execute(
            input_file=str(sample_scad_file),
        )

        # Either succeeds with OpenSCAD or fails gracefully
        assert result.success or "openscad" in result.error.lower()

    @pytest.mark.asyncio
    async def test_custom_image_size(self, tool, sample_scad_file):
        """Test custom image size parameter."""
        result = await tool.execute(
            input_file=str(sample_scad_file),
            format="png",
            image_size="1920,1080",
        )

        # Verify parameter was accepted (tool may still fail if OpenSCAD not installed)
        assert result is not None

    @pytest.mark.asyncio
    async def test_colorscheme_parameter(self, tool, sample_scad_file):
        """Test colorscheme parameter."""
        result = await tool.execute(
            input_file=str(sample_scad_file),
            format="png",
            colorscheme="Metallic",
        )

        # Verify parameter was accepted
        assert result is not None


# ═══════════════════════════════════════════════════════════════════════════════
# ExportSTLTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestExportSTLTool:
    """Test suite for STL export."""

    @pytest.fixture
    def tool(self):
        return ExportSTLTool()

    @pytest.fixture
    def sample_scad_file(self, tmp_path):
        """Create a sample .scad file for testing."""
        content = """cube([10, 10, 10]);"""
        file_path = tmp_path / "test.scad"
        file_path.write_text(content)
        return file_path

    @pytest.mark.asyncio
    async def test_file_not_found(self, tool):
        """Test handling of non-existent file."""
        result = await tool.execute(
            input_file="/nonexistent/file.scad",
        )

        assert not result.success
        assert "not found" in result.error.lower()

    @pytest.mark.asyncio
    async def test_quality_settings(self, tool):
        """Test quality settings are valid."""
        assert tool.QUALITY_SETTINGS["draft"] == 16
        assert tool.QUALITY_SETTINGS["normal"] == 32
        assert tool.QUALITY_SETTINGS["high"] == 64
        assert tool.QUALITY_SETTINGS["ultra"] == 128

    @pytest.mark.asyncio
    async def test_export_with_quality(self, tool, sample_scad_file):
        """Test export with quality parameter."""
        result = await tool.execute(
            input_file=str(sample_scad_file),
            quality="high",
        )

        # Either succeeds or fails gracefully
        assert result is not None
        if not result.success:
            assert "openscad" in result.error.lower()


# ═══════════════════════════════════════════════════════════════════════════════
# ValidateSCADTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestValidateSCADTool:
    """Test suite for OpenSCAD validation."""

    @pytest.fixture
    def tool(self):
        return ValidateSCADTool()

    @pytest.mark.asyncio
    async def test_no_input_error(self, tool):
        """Test error when no input provided."""
        result = await tool.execute()

        assert not result.success
        assert "must be provided" in result.error.lower()

    @pytest.mark.asyncio
    async def test_valid_code(self, tool):
        """Test validation of valid code."""
        result = await tool.execute(
            code="cube([10, 10, 10]);",
        )

        assert result.success
        assert result.metadata.get("errors") == 0

    @pytest.mark.asyncio
    async def test_unbalanced_braces(self, tool):
        """Test detection of unbalanced braces."""
        result = await tool.execute(
            code="module test() { cube([10,10,10]);",
        )

        assert not result.success
        assert "brace" in result.output.lower()

    @pytest.mark.asyncio
    async def test_unbalanced_brackets(self, tool):
        """Test detection of unbalanced brackets."""
        result = await tool.execute(
            code="cube([10, 10, 10);",
        )

        assert not result.success
        assert "bracket" in result.output.lower()

    @pytest.mark.asyncio
    async def test_unbalanced_parentheses(self, tool):
        """Test detection of unbalanced parentheses."""
        result = await tool.execute(
            code="cube([10, 10, 10];",
        )

        assert not result.success
        assert "parenthes" in result.output.lower()

    @pytest.mark.asyncio
    async def test_zero_dimension_cube(self, tool):
        """Test detection of zero-dimension cube."""
        result = await tool.execute(
            code="cube([0, 10, 10]);",
        )

        assert not result.success
        assert "zero" in result.output.lower()

    @pytest.mark.asyncio
    async def test_low_fn_warning(self, tool):
        """Test warning for low $fn value."""
        result = await tool.execute(
            code="$fn = 8; cylinder(h=10, r=5);",
        )

        # Should have a warning about low resolution
        assert "warning" in result.output.lower() or "low" in result.output.lower()

    @pytest.mark.asyncio
    async def test_thin_wall_warning(self, tool):
        """Test warning for thin walls."""
        result = await tool.execute(
            code="wall = 0.3; cube([10,10,10]);",
        )

        assert result.success
        # Should have a warning about thin walls
        assert "thin" in result.output.lower() or result.metadata.get("warnings", 0) > 0

    @pytest.mark.asyncio
    async def test_empty_difference_warning(self, tool):
        """Test warning for difference with single child."""
        result = await tool.execute(
            code="difference() { cube([10,10,10]); }",
        )

        # Should warn about difference with less than 2 children
        assert "warning" in result.output.lower() or result.metadata.get("warnings", 0) > 0

    @pytest.mark.asyncio
    async def test_validate_from_file(self, tool, tmp_path):
        """Test validation from file."""
        scad_file = tmp_path / "test.scad"
        scad_file.write_text("cube([10, 10, 10]);")

        result = await tool.execute(
            input_file=str(scad_file),
        )

        assert result.success

    @pytest.mark.asyncio
    async def test_file_not_found(self, tool):
        """Test handling of non-existent file."""
        result = await tool.execute(
            input_file="/nonexistent/file.scad",
        )

        assert not result.success
        assert "not found" in result.error.lower()


# ═══════════════════════════════════════════════════════════════════════════════
# ParametrizeTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestParametrizeTool:
    """Test suite for parametrization."""

    @pytest.fixture
    def tool(self):
        return ParametrizeTool()

    @pytest.mark.asyncio
    async def test_no_input_error(self, tool):
        """Test error when no input provided."""
        result = await tool.execute()

        assert not result.success
        assert "must be provided" in result.error.lower()

    @pytest.mark.asyncio
    async def test_parametrize_cube(self, tool):
        """Test parametrization of cube."""
        result = await tool.execute(
            code="cube([50, 40, 30]);",
        )

        assert result.success
        # Should extract width, depth, height parameters
        assert "width" in result.output.lower() or "parameters" in result.output.lower()

    @pytest.mark.asyncio
    async def test_parametrize_with_prefix(self, tool):
        """Test parametrization with prefix."""
        result = await tool.execute(
            code="cube([50, 40, 30]);",
            prefix="box_",
        )

        assert result.success
        if result.metadata.get("parameters"):
            # Check that parameters have prefix
            params = result.metadata["parameters"]
            has_prefixed = any(k.startswith("box_") for k in params.keys())
            # May or may not have prefix depending on implementation

    @pytest.mark.asyncio
    async def test_parametrize_from_file(self, tool, tmp_path):
        """Test parametrization from file."""
        scad_file = tmp_path / "test.scad"
        scad_file.write_text("cube([50, 40, 30]);")

        result = await tool.execute(
            input_file=str(scad_file),
        )

        assert result.success

    @pytest.mark.asyncio
    async def test_parametrize_to_new_file(self, tool, tmp_path):
        """Test parametrization to new file."""
        scad_file = tmp_path / "original.scad"
        scad_file.write_text("cube([50, 40, 30]);")
        output_file = tmp_path / "parametric.scad"

        result = await tool.execute(
            input_file=str(scad_file),
            output_file=str(output_file),
        )

        assert result.success
        assert output_file.exists()

    @pytest.mark.asyncio
    async def test_file_not_found(self, tool):
        """Test handling of non-existent file."""
        result = await tool.execute(
            input_file="/nonexistent/file.scad",
        )

        assert not result.success
        assert "not found" in result.error.lower()


# ═══════════════════════════════════════════════════════════════════════════════
# OptimizePrintabilityTool Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestOptimizePrintabilityTool:
    """Test suite for printability optimization."""

    @pytest.fixture
    def tool(self):
        return OptimizePrintabilityTool()

    @pytest.mark.asyncio
    async def test_no_input_error(self, tool):
        """Test error when no input provided."""
        result = await tool.execute()

        assert not result.success
        assert "must be provided" in result.error.lower()

    @pytest.mark.asyncio
    async def test_basic_analysis(self, tool):
        """Test basic printability analysis."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
        )

        assert result.success
        assert "printability" in result.output.lower() or "print" in result.output.lower()

    @pytest.mark.asyncio
    async def test_thin_wall_detection(self, tool):
        """Test thin wall detection."""
        result = await tool.execute(
            code="wall = 0.3; cube([10,10,10]);",
            nozzle_diameter=0.4,
        )

        assert result.success
        # Should warn about thin walls
        assert "wall" in result.output.lower() or "thin" in result.output.lower()

    @pytest.mark.asyncio
    async def test_fdm_specific_suggestions(self, tool):
        """Test FDM-specific suggestions."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
            printer_type="fdm",
        )

        assert result.success
        assert result.metadata.get("printer_type") == "fdm"
        # Should include FDM-related suggestions
        assert "FDM" in result.output.upper()

    @pytest.mark.asyncio
    async def test_sla_specific_suggestions(self, tool):
        """Test SLA-specific suggestions."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
            printer_type="sla",
        )

        assert result.success
        assert result.metadata.get("printer_type") == "sla"
        # Should include SLA-related suggestions
        assert "SLA" in result.output.upper()

    @pytest.mark.asyncio
    async def test_custom_nozzle_diameter(self, tool):
        """Test custom nozzle diameter."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
            nozzle_diameter=0.6,
        )

        assert result.success
        assert result.metadata.get("nozzle_diameter") == 0.6

    @pytest.mark.asyncio
    async def test_custom_layer_height(self, tool):
        """Test custom layer height."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
            layer_height=0.3,
        )

        assert result.success
        assert result.metadata.get("layer_height") == 0.3

    @pytest.mark.asyncio
    async def test_tolerance_suggestions_for_fit(self, tool):
        """Test tolerance suggestions for fit-related code."""
        result = await tool.execute(
            code="// This is a fit joint\ncube([50, 50, 50]);",
        )

        assert result.success
        # Should include tolerance suggestions
        assert "fit" in result.output.lower() or "tolerance" in result.output.lower()

    @pytest.mark.asyncio
    async def test_thread_suggestions(self, tool):
        """Test suggestions for threaded parts."""
        result = await tool.execute(
            code="// Screw hole\ncylinder(h=10, r=1.5);",
        )

        assert result.success
        # May include thread-related suggestions

    @pytest.mark.asyncio
    async def test_from_file(self, tool, tmp_path):
        """Test analysis from file."""
        scad_file = tmp_path / "test.scad"
        scad_file.write_text("cube([50, 50, 50]);")

        result = await tool.execute(
            input_file=str(scad_file),
        )

        assert result.success

    @pytest.mark.asyncio
    async def test_file_not_found(self, tool):
        """Test handling of non-existent file."""
        result = await tool.execute(
            input_file="/nonexistent/file.scad",
        )

        assert not result.success
        assert "not found" in result.error.lower()

    @pytest.mark.asyncio
    async def test_print_settings_recommendations(self, tool):
        """Test that print settings recommendations are included."""
        result = await tool.execute(
            code="cube([50, 50, 50]);",
        )

        assert result.success
        # Should include print settings recommendations
        assert "settings" in result.output.lower() or "layer" in result.output.lower()


# ═══════════════════════════════════════════════════════════════════════════════
# Integration Tests
# ═══════════════════════════════════════════════════════════════════════════════


class TestOpenSCADToolsIntegration:
    """Integration tests for OpenSCAD tools."""

    @pytest.mark.asyncio
    async def test_tools_registered(self):
        """Test that all OpenSCAD tools are registered in the registry."""
        from sindri.tools.registry import ToolRegistry

        registry = ToolRegistry.default()

        assert registry.get_tool("generate_scad") is not None
        assert registry.get_tool("render_preview") is not None
        assert registry.get_tool("export_stl") is not None
        assert registry.get_tool("validate_scad") is not None
        assert registry.get_tool("parametrize_model") is not None
        assert registry.get_tool("optimize_printability") is not None

    @pytest.mark.asyncio
    async def test_volundr_agent_exists(self):
        """Test that Völundr agent is defined in the registry."""
        from sindri.agents.registry import AGENTS, get_agent

        assert "volundr" in AGENTS

        volundr = get_agent("volundr")
        assert volundr.name == "volundr"
        assert "openscad" in volundr.role.lower() or "3d" in volundr.role.lower()
        assert "generate_scad" in volundr.tools
        assert "render_preview" in volundr.tools
        assert "export_stl" in volundr.tools
        assert "validate_scad" in volundr.tools
        assert "parametrize_model" in volundr.tools
        assert "optimize_printability" in volundr.tools

    @pytest.mark.asyncio
    async def test_brokkr_can_delegate_to_volundr(self):
        """Test that Brokkr can delegate to Völundr."""
        from sindri.agents.registry import get_agent

        brokkr = get_agent("brokkr")
        assert "volundr" in brokkr.delegate_to

    @pytest.mark.asyncio
    async def test_generate_and_validate_workflow(self):
        """Test workflow: generate then validate."""
        gen_tool = GenerateSCADTool()
        val_tool = ValidateSCADTool()

        # Generate code
        gen_result = await gen_tool.execute(
            description="A simple box with lid",
            width=50,
            height=30,
            depth=40,
        )
        assert gen_result.success

        # Extract code from markdown code block
        code = gen_result.output
        if "```scad" in code:
            code = code.split("```scad")[1].split("```")[0].strip()

        # Validate generated code
        val_result = await val_tool.execute(code=code)
        assert val_result.success
        assert val_result.metadata.get("errors") == 0

    @pytest.mark.asyncio
    async def test_full_workflow(self):
        """Test complete workflow: generate, validate, analyze printability."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)

            # Generate model
            gen_tool = GenerateSCADTool(work_dir=tmpdir)
            gen_result = await gen_tool.execute(
                description="Enclosure for electronics",
                width=80,
                height=40,
                depth=60,
                output_file="case.scad",
            )
            assert gen_result.success
            assert (tmpdir / "case.scad").exists()

            # Validate model
            val_tool = ValidateSCADTool(work_dir=tmpdir)
            val_result = await val_tool.execute(
                input_file="case.scad",
            )
            assert val_result.success

            # Analyze printability
            opt_tool = OptimizePrintabilityTool(work_dir=tmpdir)
            opt_result = await opt_tool.execute(
                input_file="case.scad",
                printer_type="fdm",
                nozzle_diameter=0.4,
            )
            assert opt_result.success
